Аналог foreach
У багатьох мовах існує більш компактна форма for для перебору елементів масивів - foreach. Конструкція foreach не вимагає ручного зміни змінної-кроку для перебору - цикл автоматично виконує цю роботу.
В Java вирішили не додавати нове ключове слово, а просто зробили вдосконалений вид циклу for, який має вигляд: for(тип итер_пер : коллекция) блок_операторів
Для порівняння напишемо цикл для обчислення суми значень елементів масиву традиційним способом: 
int[] nums = { 1, 2, 3, 4, 5 };
int sum = 0; 
for(int i = 0; i < 5; i++) sum += nums[i];
Цей код можна переписати таким чином:
int[] nums = { 1, 2, 3, 4, 5 };
int sum = 0; 
for(int i : nums) sum += i;

При проходженні циклу змінної i автоматично присвоюється значення, рівне значенню наступного елемента масиву nums. Таким чином, при першому проходженні змінна i містить значення 1, при другому - 2 і т.д. Крім того при такому способі виключається можливість помилок виходу за межі масиву.Для цього способу можна використовувати масив або будь-який клас з інтерфейсом Iterable.Можна перервати виконання циклу за допомогою оператора break: 
int[] nums = { 1, 2, 3, 4, 5 };
int sum = 0; 
for(int i : nums) {
    sum += i;
	if(i == 3) break; // зупиняємо цикл, якщо значення дорівнює 3
}
Врахуйте, що в циклі в стилі foreach итерационная змінна доступна тільки для читання, так як вона пов'язана тільки з вихідним масивом. Навіть якщо ви зміните її значення, то це не вплине на роботу з масивом.Також можна використовувати даний спосіб для багатовимірних масивів.Оскільки кожен оператор for в стилі foreach перебирає елементи масиву послідовно, починаючи з першого і закінчуючи останнім, то даний спосіб зручний для багатьох операцій. Наприклад, для пошуку значення в неврегульованих масиві. Пошук припиняється після виявлення потрібного значення.

int[] nums = { 3, 1, 6, 4, 9, 5, 8, 2 }; 
int val = 5;
boolean found = false; 
// шукаємо значення 5 в масиві
for (int x : nums) {
	if (x == val) {
		found = true;
		break;
	}
} 
if (found) {
	mInfoTextView.setText("Значення знайдено");
}

Так як у нас невпорядкований список, то нам потрібно послідовно пройтися по всіх елементах. Якщо нам пощастить і потрібне значення зустрінеться при переборі, то виходимо з циклу.
